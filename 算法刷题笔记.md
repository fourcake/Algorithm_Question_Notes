# 算法刷题笔记

## 第零章  前  言

1. 数据结构基本分成两大类：数组和链表。对数据结构的操作大多数基于遍历访问，框架如下：

   ```c++
   void traverse(int[] arr) {
       for (int i = 0; i < arr.length; i++) {
           // 迭代访问 arr[i]
       }
   }
   ```

   ```c++
   /* 基本的单链表节点 */
   class ListNode {
       int val;
       ListNode next;
   }
   
   void traverse(ListNode head) {
       for (ListNode p = head; p != null; p = p.next) {
           // 迭代访问 p.val
       }
   }
   
   void traverse(ListNode head) {
       // 递归访问 head.val
       traverse(head.next);
   ```

   ```c++
   /* 基本的二叉树节点 */
   class TreeNode {
       int val;
       TreeNode left, right;
   }
   
   void traverse(TreeNode root) {
       traverse(root.left);
       traverse(root.right);
   }
   ```

   ```C++
   /* 基本的 N 叉树节点 */
   class TreeNode {
       int val;
       TreeNode[] children;//孩子用数组表示
   }
   
   void traverse(TreeNode root) {
       for (TreeNode child : root.children)
           traverse(child);
   }
   ```

2. 待补充

## 第一章  手把手刷数据结构

### 链表

1. **leetcode23「合并K个升序链表」**PriorityQueue中的元素在逻辑上构成了一棵完全二叉树，但是在实际存储时转换为了数组保存在内存中，它在遍历输出的时候总是先输出根节点的值，然后调整树使之继续成为一棵完全二叉树，每次输出的根节点总是整棵树优先级最高的，要么数值最小要么数值最大。

2. **leetcode19「删除链表的倒数第 N 个结点」**删除倒数第N个结点，就得获得倒数第n+1个节点的引用，如何找到倒数第k个节点，设置快慢指针，快指针先走k步即可。

3. **leetcode876「链表的中间结点」**快指针走两步，慢指针走一步

4. **判断链表是否包含环**同样的技巧，快指针走两步慢指针走一步，若是快慢指针相遇，则说明有环。若是要**找到环的起点**，则可以当快慢指针相遇时，慢指针重新指回头节点，然后两指针同步进行，相遇点即为环的起点。 

   <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220221212824498.png" alt="image-20220221212824498" style="zoom:60%;" />

   ```java
   ListNode detectCycle(ListNode head) {
       ListNode fast, slow;
       fast = slow = head;
       while (fast != null && fast.next != null) {
           fast = fast.next.next;
           slow = slow.next;
           if (fast == slow) break;
       }
       if (fast == null || fast.next == null) {
           // fast 遇到空指针说明没有环
           return null;
       }
   
       // 重新指向头结点
       slow = head;
       // 快慢指针同步前进，相交点就是环起点
       while (slow != fast) {
           fast = fast.next;
           slow = slow.next;
       }
       return slow;
   }
   ```

5. **leetcode160 「相交链表」**给你输入两个链表的头结点 headA和 headB，找出交点或NULL。

   解法1：让p1,p2分别遍历A，B链表，当遍历结束时，将另一个链表接在后面，这样进行拼接，就可以让 p1和p2 同时进入公共部分，也就是同时到达相交节点

   解法2：可以将A链表的结尾指向B链表的开头，问题转化为寻找链表中环的起点的问题
   
5. **leetcode206「反转链表」**重点在于递归解决思想，下面语句是核心

   ```java
   ListNode last = reverse(head.next);
   head.next.next=head;
   head.next=null;
   ```
   
   **「反转链表前 N 个节点」**
   
   ```java
   ListNode reverseN(ListNode head, int n) {
       if (n == 1) {
           // 记录第 n + 1 个节点
           successor = head.next;
           return head;
       }
       // 以 head.next 为起点，需要反转前 n - 1 个节点
       ListNode last = reverseN(head.next, n - 1);
   
       head.next.next = head;
       // 让反转之后的 head 节点和后面的节点连起来
       head.next = successor;
       return last;
   }
   ```
   
   **「反转链表的部分节点」**即给一个索引区间 [left,right]（索引从 1 开始），仅仅反转区间中的链表元素
   
   注意，若left=1，即转化为反转链表前right个节点；
   
   而当left!=1时，如果我们把head的索引视为 1，那么我们是想从第 m个元素开始反转，如果把 head.next的索引视为 1，那么相对于 head.next，反转的区间应该是从第 m - 1 个元素开始的，那么对于 head.next.next 呢……，直到最后相当于单个节点翻转，这就是递归
   
   ```java
   class Solution {
       ListNode successor=null;
       public ListNode reverseBetween(ListNode head, int left, int right) {
           if(left==1){
               return reverseN(head, right);
           }
            head.next = reverseBetween(head.next, left - 1, right - 1);
            return head;
       }
       public ListNode reverseN(ListNode head,int right){
           if(right==1){
               successor=head.next;
               return head;
           }
           ListNode last=reverseN(head.next,right-1);
           head.next.next=head;
           head.next=successor;
           return last;
       }
   }
   ```
   
7. **leetcode25「反转链表的部分节点」**

   首先实现翻转部分区间，从翻转整个链表的迭代法入手，

   ```java
   ListNode reverse(ListNode a) {
       ListNode pre, cur, nxt;
   	pre=null,cur=a,nxt=a;
   	 while (cur != null) {
           nxt = cur.next;
           // 逐个结点反转
           cur.next = pre;
           // 更新指针位置
           pre = cur;
           cur = nxt;
        }
       return pre;
   }
   ```

   如上所示，可以看出，若是翻转a到b之间的链表，只需要修改while判定条件即可；将上述过程融入迭代过程，即可实现按组翻转节点

   ```java
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head==null){
            return head;
        }
        ListNode a,b=head;
   	for(int i=0;i<k;i++){
           if (b == null) 
               return head;
           b = b.next;
       }
        ListNode newHead = reverse(a, b);
        a.next = reverseKGroup(b, k);
        return newHead;
    }
    
   ```

8. **leetcode 234 「反转链表的部分节点」**首先寻找回文串的核心思想是从中心向两端扩展，判断的话从两端到中心。

   由于单链表无法倒着遍历，无法使用双指针技巧，那么最简单的办法就是把原始链表反转存入一条新的链表，然后比较这两条链表是否相同。

   换个思路，链表--->二叉树，借助二叉树后序遍历的思路，链表兼具递归结构，树结构不过是链表的衍生，链表其实也可以有前序遍历和后序遍历：

   ```java
   void traverse(ListNode head) {
       // 前序遍历代码
       traverse(head.next);
       // 后序遍历代码
   }
   ```

   **实际上就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的**，只不过利用的是递归函数的堆栈

   ```java
   // 左侧指针
   ListNode left;
   
   boolean isPalindrome(ListNode head) {
       left = head;
       return traverse(head);
   }
   
   boolean traverse(ListNode right) {
       if (right == null) return true;
       boolean res = traverse(right.next);
       // 后序遍历代码，即判断是否是回文链
       res = res && (right.val == left.val);
       left = left.next;
       return res;
   }
   ```

   

### 二叉树

1. 二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着回溯算法核心框架和动态规划核心框架。

2. **leetcode 104 「二叉树的最大深度」**显然遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度，**这就是遍历二叉树计算答案的思路**。

   ```java
   // 记录最大深度
   int res = 0;
   // 记录遍历到的节点的深度
   int depth = 0;
   
   // 主函数
   int maxDepth(TreeNode root) {
   	traverse(root);
   	return res;
   }
   
   // 二叉树遍历框架
   void traverse(TreeNode root) {
   	if (root == null) {
   		// 到达叶子节点，更新最大深度
   		res = Math.max(res, depth);
   		return;
   	}
   	// 前序位置
   	depth++;
   	traverse(root.left);
   	traverse(root.right);
   	// 后序位置
   	depth--;
   }
   ```

   同样的，一棵树的最大深度可以有子树的最大深度推出，**这就是分解问题计算答案的思路**。

   ```java
   // 定义：输入根节点，返回这棵二叉树的最大深度
   int maxDepth(TreeNode root) {
   	if (root == null) {
   		return 0;
   	}
   	// 利用定义，计算左右子树的最大深度
   	int leftMax = maxDepth(root.left);
   	int rightMax = maxDepth(root.right);
   	// 整棵树的最大深度等于左右子树的最大深度取最大值，
       // 然后再加上根节点自己
   	int res = Math.max(leftMax, rightMax) + 1;
   
   	return res;
   }
   ```

3. 和前序位置对比，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的：**这意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

   1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？(前序)

   2、如何打印出每个节点的左右子树各有多少节点？（后序）

4. **leetcode 226「翻转二叉树」**细想，可以在前序或后序时插入交换子树操作，前序是从顶向下，后序从底向上

   ```Java
    public TreeNode invertTree(TreeNode root) {
           if(root==null) return null;
           invertTree(root.left);
           invertTree(root.right);
           //可放在前序也可放在后序
           TreeNode tmp = root.left;
           root.left = root.right;
           root.right = tmp;
           return root;
       }
   ```

5. **leetcode 116「填充二叉树节点的右侧指针」**首先若是模仿上一题代码，在前序遍历时直接 root.left.next = root.right，会导致以下问题

   <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220223145814649.png" alt="image-20220223145814649" style="zoom:50%;" />

   2号无法指向3号，5号无法指向6号，因为它们不是同一个父节点。**因此增加函数参数，一个节点做不到，就给他安排两个节点，将每一层二叉树节点连接起来可以细化成将每两个相邻节点都连接起来**

   ```java
   // 主函数
   Node connect(Node root) {
       if (root == null) return null;
       connectTwoNode(root.left, root.right);
       return root;
   }
   
   // 辅助函数
   void connectTwoNode(Node node1, Node node2) {
       if (node1 == null || node2 == null) {
           return;
       }
       /**** 前序遍历位置 ****/
       // 将传入的两个节点连接
       node1.next = node2;
       // 连接相同父节点的两个子节点
       connectTwoNode(node1.left, node1.right);
       connectTwoNode(node2.left, node2.right);
       // 连接跨越父节点的两个子节点
       connectTwoNode(node1.right, node2.left);
   }
   ```

   或者采用层序遍历更简单

6. **leetcode114 将二叉树展开为链表**

   ```java
   // 定义：将以 root 为根的树拉平为链表
   void flatten(TreeNode root) {
       // base case
       if (root == null) return;
       
       flatten(root.left);
       flatten(root.right);
   
       /**** 后序遍历位置 ****/
       // 1、保存副本
       TreeNode left = root.left;
       TreeNode right = root.right;
       
       // 2、将左子树作为右子树
       root.left = null;
       root.right = left;
   
       // 3、将原先的右子树接到当前右子树的末端
       TreeNode p = root;
       while (p.right != null) {
           p = p.right;
       }
       p.right = right;
   }
   ```

7. 

### 图算法



### 数组