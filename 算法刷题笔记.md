# 算法刷题笔记

## 第零章  前  言

1. 数据结构基本分成两大类：数组和链表。对数据结构的操作大多数基于遍历访问，框架如下：

   ```c++
   void traverse(int[] arr) {
       for (int i = 0; i < arr.length; i++) {
           // 迭代访问 arr[i]
       }
   }
   ```

   ```c++
   /* 基本的单链表节点 */
   class ListNode {
       int val;
       ListNode next;
   }
   
   void traverse(ListNode head) {
       for (ListNode p = head; p != null; p = p.next) {
           // 迭代访问 p.val
       }
   }
   
   void traverse(ListNode head) {
       // 递归访问 head.val
       traverse(head.next);
   ```

   ```c++
   /* 基本的二叉树节点 */
   class TreeNode {
       int val;
       TreeNode left, right;
   }
   
   void traverse(TreeNode root) {
       traverse(root.left);
       traverse(root.right);
   }
   ```

   ```C++
   /* 基本的 N 叉树节点 */
   class TreeNode {
       int val;
       TreeNode[] children;//孩子用数组表示
   }
   
   void traverse(TreeNode root) {
       for (TreeNode child : root.children)
           traverse(child);
   }
   ```

2. 待补充

## 第一章  手把手刷数据结构

### 链表

1. **leetcode23「合并K个升序链表」**PriorityQueue中的元素在逻辑上构成了一棵完全二叉树，但是在实际存储时转换为了数组保存在内存中，它在遍历输出的时候总是先输出根节点的值，然后调整树使之继续成为一棵完全二叉树，每次输出的根节点总是整棵树优先级最高的，要么数值最小要么数值最大。

2. **leetcode19「删除链表的倒数第 N 个结点」**删除倒数第N个结点，就得获得倒数第n+1个节点的引用，如何找到倒数第k个节点，设置快慢指针，快指针先走k步即可。

3. **leetcode876「链表的中间结点」**快指针走两步，慢指针走一步

4. **判断链表是否包含环**同样的技巧，快指针走两步慢指针走一步，若是快慢指针相遇，则说明有环。若是要**找到环的起点**，则可以当快慢指针相遇时，慢指针重新指回头节点，然后两指针同步进行，相遇点即为环的起点。 

   <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220221212824498.png" alt="image-20220221212824498" style="zoom:60%;" />

   ```java
   ListNode detectCycle(ListNode head) {
       ListNode fast, slow;
       fast = slow = head;
       while (fast != null && fast.next != null) {
           fast = fast.next.next;
           slow = slow.next;
           if (fast == slow) break;
       }
       if (fast == null || fast.next == null) {
           // fast 遇到空指针说明没有环
           return null;
       }
   
       // 重新指向头结点
       slow = head;
       // 快慢指针同步前进，相交点就是环起点
       while (slow != fast) {
           fast = fast.next;
           slow = slow.next;
       }
       return slow;
   }
   ```

5. **leetcode160 「相交链表」**给你输入两个链表的头结点 headA和 headB，找出交点或NULL。

   解法1：让p1,p2分别遍历A，B链表，当遍历结束时，将另一个链表接在后面，这样进行拼接，就可以让 p1和p2 同时进入公共部分，也就是同时到达相交节点

   解法2：可以将A链表的结尾指向B链表的开头，问题转化为寻找链表中环的起点的问题
   
5. **leetcode206「反转链表」**重点在于递归解决思想，下面语句是核心

   ```java
   ListNode last = reverse(head.next);
   head.next.next=head;
   head.next=null;
   ```
   
   **「反转链表前 N 个节点」**
   
   ```java
   ListNode reverseN(ListNode head, int n) {
       if (n == 1) {
           // 记录第 n + 1 个节点
           successor = head.next;
           return head;
       }
       // 以 head.next 为起点，需要反转前 n - 1 个节点
       ListNode last = reverseN(head.next, n - 1);
   
       head.next.next = head;
       // 让反转之后的 head 节点和后面的节点连起来
       head.next = successor;
       return last;
   }
   ```
   
   **「反转链表的部分节点」**即给一个索引区间 [left,right]（索引从 1 开始），仅仅反转区间中的链表元素
   
   注意，若left=1，即转化为反转链表前right个节点；
   
   而当left!=1时，如果我们把head的索引视为 1，那么我们是想从第 m个元素开始反转，如果把 head.next的索引视为 1，那么相对于 head.next，反转的区间应该是从第 m - 1 个元素开始的，那么对于 head.next.next 呢……，直到最后相当于单个节点翻转，这就是递归
   
   ```java
   class Solution {
       ListNode successor=null;
       public ListNode reverseBetween(ListNode head, int left, int right) {
           if(left==1){
               return reverseN(head, right);
           }
            head.next = reverseBetween(head.next, left - 1, right - 1);
            return head;
       }
       public ListNode reverseN(ListNode head,int right){
           if(right==1){
               successor=head.next;
               return head;
           }
           ListNode last=reverseN(head.next,right-1);
           head.next.next=head;
           head.next=successor;
           return last;
       }
   }
   ```
   
7. **leetcode25「反转链表的部分节点」**

   首先实现翻转部分区间，从翻转整个链表的迭代法入手，

   ```java
   ListNode reverse(ListNode a) {
       ListNode pre, cur, nxt;
   	pre=null,cur=a,nxt=a;
   	 while (cur != null) {
           nxt = cur.next;
           // 逐个结点反转
           cur.next = pre;
           // 更新指针位置
           pre = cur;
           cur = nxt;
        }
       return pre;
   }
   ```

   如上所示，可以看出，若是翻转a到b之间的链表，只需要修改while判定条件即可；将上述过程融入迭代过程，即可实现按组翻转节点

   ```java
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head==null){
            return head;
        }
        ListNode a,b=head;
   	for(int i=0;i<k;i++){
           if (b == null) 
               return head;
           b = b.next;
       }
        ListNode newHead = reverse(a, b);
        a.next = reverseKGroup(b, k);
        return newHead;
    }
    
   ```

8. **leetcode 234 「反转链表的部分节点」**首先寻找回文串的核心思想是从中心向两端扩展，判断的话从两端到中心。

   由于单链表无法倒着遍历，无法使用双指针技巧，那么最简单的办法就是把原始链表反转存入一条新的链表，然后比较这两条链表是否相同。

   换个思路，链表--->二叉树，借助二叉树后序遍历的思路，链表兼具递归结构，树结构不过是链表的衍生，链表其实也可以有前序遍历和后序遍历：

   ```java
   void traverse(ListNode head) {
       // 前序遍历代码
       traverse(head.next);
       // 后序遍历代码
   }
   ```

   **实际上就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的**，只不过利用的是递归函数的堆栈

   ```java
   // 左侧指针
   ListNode left;
   
   boolean isPalindrome(ListNode head) {
       left = head;
       return traverse(head);
   }
   
   boolean traverse(ListNode right) {
       if (right == null) return true;
       boolean res = traverse(right.next);
       // 后序遍历代码，即判断是否是回文链
       res = res && (right.val == left.val);
       left = left.next;
       return res;
   }
   ```

   

### 二叉树

1. 二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着回溯算法核心框架和动态规划核心框架。

2. **leetcode 104 「二叉树的最大深度」**显然遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度，**这就是遍历二叉树计算答案的思路**。

   ```java
   // 记录最大深度
   int res = 0;
   // 记录遍历到的节点的深度
   int depth = 0;
   
   // 主函数
   int maxDepth(TreeNode root) {
   	traverse(root);
   	return res;
   }
   
   // 二叉树遍历框架
   void traverse(TreeNode root) {
   	if (root == null) {
   		// 到达叶子节点，更新最大深度
   		res = Math.max(res, depth);
   		return;
   	}
   	// 前序位置
   	depth++;
   	traverse(root.left);
   	traverse(root.right);
   	// 后序位置
   	depth--;
   }
   ```

   同样的，一棵树的最大深度可以有子树的最大深度推出，**这就是分解问题计算答案的思路**。

   ```java
   // 定义：输入根节点，返回这棵二叉树的最大深度
   int maxDepth(TreeNode root) {
   	if (root == null) {
   		return 0;
   	}
   	// 利用定义，计算左右子树的最大深度
   	int leftMax = maxDepth(root.left);
   	int rightMax = maxDepth(root.right);
   	// 整棵树的最大深度等于左右子树的最大深度取最大值，
       // 然后再加上根节点自己
   	int res = Math.max(leftMax, rightMax) + 1;
   
   	return res;
   }
   ```

3. 和前序位置对比，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的：**这意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

   1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？(前序)

   2、如何打印出每个节点的左右子树各有多少节点？（后序）

4. **leetcode 226「翻转二叉树」**细想，可以在前序或后序时插入交换子树操作，前序是从顶向下，后序从底向上

   ```Java
    public TreeNode invertTree(TreeNode root) {
           if(root==null) return null;
           invertTree(root.left);
           invertTree(root.right);
           //可放在前序也可放在后序
           TreeNode tmp = root.left;
           root.left = root.right;
           root.right = tmp;
           return root;
       }
   ```

5. **leetcode 116「填充二叉树节点的右侧指针」**首先若是模仿上一题代码，在前序遍历时直接 root.left.next = root.right，会导致以下问题

   <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220223145814649.png" alt="image-20220223145814649" style="zoom:50%;" />

   2号无法指向3号，5号无法指向6号，因为它们不是同一个父节点。**因此增加函数参数，一个节点做不到，就给他安排两个节点，将每一层二叉树节点连接起来可以细化成将每两个相邻节点都连接起来**

   ```java
   // 主函数
   Node connect(Node root) {
       if (root == null) return null;
       connectTwoNode(root.left, root.right);
       return root;
   }
   
   // 辅助函数
   void connectTwoNode(Node node1, Node node2) {
       if (node1 == null || node2 == null) {
           return;
       }
       /**** 前序遍历位置 ****/
       // 将传入的两个节点连接
       node1.next = node2;
       // 连接相同父节点的两个子节点
       connectTwoNode(node1.left, node1.right);
       connectTwoNode(node2.left, node2.right);
       // 连接跨越父节点的两个子节点
       connectTwoNode(node1.right, node2.left);
   }
   ```

   或者采用层序遍历更简单

6. **leetcode114 将二叉树展开为链表**

   ```java
   // 定义：将以 root 为根的树拉平为链表
   void flatten(TreeNode root) {
       // base case
       if (root == null) return;
       
       flatten(root.left);
       flatten(root.right);
   
       /**** 后序遍历位置 ****/
       // 1、保存副本
       TreeNode left = root.left;
       TreeNode right = root.right;
       
       // 2、将左子树作为右子树
       root.left = null;
       root.right = left;
   
       // 3、将原先的右子树接到当前右子树的末端
       TreeNode p = root;
       while (p.right != null) {
           p = p.right;
       }
       p.right = right;
   }
   ```

7. **leetcode 654 「构造最大二叉树」**根据题意，我们肯定要遍历数组把找到最大值 maxVal，把根节点 root做出来，然后对 maxVal左边的数组和右边的数组进行递归调用，作为 root的左右子树。按照题目给出的例子，输入的数组为 `[3,2,1,6,0,5]`，对于整棵树的根节点来说，其实在做这件事

   ```java
   TreeNode constructMaximumBinaryTree([3,2,1,6,0,5]) {
       // 找到数组中的最大值
       TreeNode root = new TreeNode(6);
       // 递归调用构造左右子树
       root.left = constructMaximumBinaryTree([3,2,1]);
       root.right = constructMaximumBinaryTree([0,5]);
       return root;
   }
   ```

   明确思路，再写一个辅助函数build来帮助控制nums的索引

   ```java
   /* 将 nums[lo..hi] 构造成符合条件的树，返回根节点 */
   TreeNode build(int[] nums, int lo, int hi) {
       // base case
       if (lo > hi) {
           return null;
       }
       //…………
   }
   ```

8. **leetcode 105 「通过前序和中序遍历还原二叉树」**纸老虎，直接想思路，首先思考，根节点应该做什么。**类似上一题，肯定要想办法确定根节点的值，把根节点做出来，然后递归构造左右子树即可**。

   <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220224112848257.png" alt="image-20220224112848257" style="zoom:67%;" />

   如上图所示，根节点很容易找到，preOrder的第一个元素就是，关键在于如何通过根节点的值，将 preorder 和 postorder 数组划分成两半，构造根节点的左右子树，即问号处填什么

   ```java
   TreeNode build(int[] preorder, int preStart, int preEnd, 
                  int[] inorder, int inStart, int inEnd) {
       // root 节点对应的值就是前序遍历数组的第一个元素
       int rootVal = preorder[preStart];
       // rootVal 在中序遍历数组中的索引
       int index = 0;
       for (int i = inStart; i <= inEnd; i++) {
           if (inorder[i] == rootVal) {
               index = i;
               break;
           }
       }
       TreeNode root = new TreeNode(rootVal);
       // 递归构造左右子树
       root.left = build(preorder, ?, ?, inorder, ?, ?);
   
       root.right = build(preorder, ?, ?, inorder, ?, ?);
       return root;
   }
   
   ```

   <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220224112904491.png" alt="image-20220224112904491" style="zoom:67%;" />

   显然，左右子树划分应该为

   ```java
   root.left = build(preorder, preStart+1, preStart+leftSize, inorder, inStart, index-1);
   root.right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index+1, inEnd);
   ```

9. **leetcode 106 「通过后序和中序遍历还原二叉树」**原理和上题一摸一样

   ```java
   public TreeNode build(int[] inorder,int inStart,int inEnd, int[] postorder,int postStart,int postEnd) {
           if (postStart > postEnd) {
               return null;
           }
           int rootVal = postorder[postEnd];
           int index = 0;
           for (int i = inStart; i <= inEnd; i++) {
               if (inorder[i] == rootVal) {
                   index = i;
                   break;
               }
           }
           TreeNode root = new TreeNode(rootVal);
           int leftSize = index - inStart;
           // 递归构造左右子树
           root.left = build(inorder, inStart, index-1,postorder, postStart, postStart + leftSize - 1);
   
           root.right = build(inorder, index+1, inEnd,postorder, postStart + leftSize, postEnd - 1);
   
           return root;
        }
   ```

10. **leetcode 889 「根据前序和后序遍历构造二叉树」**这道题和前两道题有一个本质的区别：**通过前序中序，或者后序中序遍历结果可以确定一棵原始二叉树，但是通过前序后序遍历结果无法确定原始二叉树**。

    不过话说回来，用后序遍历和前序遍历结果还原二叉树，解法逻辑上和前两道题差别不大，也是通过控制左右子树的索引来构建：
    
    **1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值**。
    
    **2、然后把前序遍历结果的第二个元素作为左子树的根节点的值**。
    
    **3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可**。
    
    <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220226184129317.png" alt="image-20220226184129317" style="zoom:67%;" />
    
    ```java
     TreeNode build(int[] preorder, int preStart, int preEnd,
                       int[] postorder, int postStart, int postEnd) {
            if (preStart > preEnd) {
                return null;
            }
            if (preStart == preEnd) {
                return new TreeNode(preorder[preStart]);
            }
    
            // root 节点对应的值就是前序遍历数组的第一个元素
            int rootVal = preorder[preStart];
            // root.left 的值是前序遍历第二个元素
            // 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点
            // 确定 preorder 和 postorder 中左右子树的元素区间
            int leftRootVal = preorder[preStart + 1];
            // leftRootVal 在后序遍历数组中的索引
            int index = 0;
            for (int i = postStart; i < postEnd; i++) {
                if (postorder[i] == leftRootVal) {
                    index = i;
                    break;
                }
            }
            // 左子树的元素个数
            int leftSize = index - postStart + 1;
    
            // 先构造出当前根节点
            TreeNode root = new TreeNode(rootVal);
            // 递归构造左右子树
            // 根据左子树的根节点索引和元素个数推导左右子树的索引边界
            root.left = build(preorder, preStart + 1, preStart + leftSize,
                    postorder, postStart, index);
            root.right = build(preorder, preStart + leftSize + 1, preEnd,
                    postorder, index + 1, postEnd - 1);
    
            return root;
    }
    ```
    
11. **leetcode 652「寻找重复的子树」**给定一棵二叉树 root，返回所有重复的子树

    <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220226184144398.png" alt="image-20220226184144398" style="zoom:67%;" />

    首先思考框架，我要找到相同的子树，首先我得知道自己节点的子树长什么样，其次，我还得知道别人的子树长什么样子，这样才能对比，因此选择后序遍历框架

    决定框架后，思考，如何对比子树是否长得一样，这就涉及到树的序列化，将树表示成一串字符串，空处用#表示

    当有了子树序列后，如何判断是否重复呢，运用hashmap可以很好的解决此问题

    ```java
    class Solution {
        HashMap <String,Integer> memo=new HashMap<>();
        LinkedList <TreeNode> res=new LinkedList<>();
    
        public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
            travers(root);
            return res;
        }
        public String travers(TreeNode root){
            if(root==null){
                return "#";
            }
            String left=travers(root.left);
            String right=travers(root.right);
            //序列化框架
            String subTree=left+","+right+","+root.val;
            //getOrDefault：查找目标值，获取指定key对应的value，若是不存在，则返回默认参数
            int freq=memo.getOrDefault(subTree,0);
            if(freq==1){
                res.add(root);
            }
            memo.put(subTree,freq+1);
            return subTree;
        }
    }
    ```

12. 大厦

### 二叉搜索树

二叉搜索树（BST）并不算复杂，直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。

1. **leetcode 230「二叉搜索树的第k小元素」**BST 的中序遍历其实就是升序排序的结果，每次寻找第 k 小的元素都要中序遍历一次，最坏的时间复杂度是 O(N)，相对于BST的性质来说有点低效了，计算第k小元素，最好的算法肯定也是对数级别的复杂度。

   想找到第 k小的元素并且达到对数级复杂度，关键也在于每个节点得知道他自己排第几

   <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220301211654780.png" alt="image-20220301211654780" style="zoom:67%;" />

   需要在二叉树节点中维护额外信息。**每个节点需要记录，以自己为根的这棵二叉树有多少个节点**。

2. **leetcode 538「将二叉搜索树转换为累加树」**还是利用 BST 的中序遍历特性，降序排列只要把递归顺序改一下就行了：**因此可以降序打印 BST 节点的值，如果维护一个外部累加变量 `sum`，然后把 `sum` 赋值给 BST 中的每一个节点，即可**

   ```java
   TreeNode convertBST(TreeNode root) {
       traverse(root);
       return root;
   }
   
   // 记录累加和
   int sum = 0;
   void traverse(TreeNode root) {
       if (root == null) {
           return;
       }
       traverse(root.right);
       // 维护累加和
       sum += root.val;
       // 将 BST 转化成累加树
       root.val = sum;
       traverse(root.left);
   }
   ```

3. **leetcode 98「验证二叉搜索树」**需要注意的是，单纯比较当前节点和其左右子树大小是无法完整验证BST的，对于某一个节点 root，他只能管得了自己的左右子节点，怎么把 root 的约束传递给左右子树呢？

   **通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点**

   ```java
   boolean isValidBST(TreeNode root) {
       return isValidBST(root, null, null);
   }
   
   /* 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val */
   boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
       // base case
       if (root == null) return true;
       // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
       if (min != null && root.val <= min.val) return false;
       if (max != null && root.val >= max.val) return false;
       // 限定左子树的最大值是 root.val，右子树的最小值是 root.val
       return isValidBST(root.left, min, root) 
           && isValidBST(root.right, root, max);
   }
   
   ```

4. **leetcode 700「二叉搜索树中的搜索」**运用性质

   ```java
   TreeNode searchBST(TreeNode root, int target) {
       if (root == null) {
           return null;
       }
       // 去左子树搜索
       if (root.val > target) {
           return searchBST(root.left, target);
       }
       // 去右子树搜索
       if (root.val < target) {
           return searchBST(root.right, target);
       }
       return root;
   }
   
   ```

5. **leetcode 701「二叉搜索树中的插入」**

   ```java
   TreeNode insertIntoBST(TreeNode root, int val) {
       // 找到空位置插入新节点
       if (root == null) return new TreeNode(val);
       // if (root.val == val)
       //     BST 中一般不会插入已存在元素
       if (root.val < val) 
           root.right = insertIntoBST(root.right, val);
       if (root.val > val) 
           root.left = insertIntoBST(root.left, val);
       return root;
   }
   ```

   

6.  **leetcode 450「二叉搜索树中的删除」**跟插入操作类似，先「找」再「改」，框架如下：

   ```java
   TreeNode deleteNode(TreeNode root, int key) {
       if (root.val == key) {
           // 找到啦，进行删除
       } else if (root.val > key) {
           // 去左子树找
           root.left = deleteNode(root.left, key);
       } else if (root.val < key) {
           // 去右子树找
           root.right = deleteNode(root.right, key);
       }
       return root;
   }
   ```

   找到之后，分三种情况进行删除操作：恰好是叶子节点、有一个孩子为空、有两个子节点

   ```java
   TreeNode deleteNode(TreeNode root, int key) {
       if (root == null) return null;
       if (root.val == key) {
           // 这两个 if 把情况 1 和 2 都正确处理了
           if (root.left == null) return root.right;
           if (root.right == null) return root.left;
           // 处理情况 3
           // 获得右子树最小的节点
           TreeNode minNode = getMin(root.right);
           // 删除右子树最小的节点
           root.right = deleteNode(root.right, minNode.val);
           // 用右子树最小的节点替换 root 节点
           minNode.left = root.left;
           minNode.right = root.right;
           root = minNode;
       } else if (root.val > key) {
           root.left = deleteNode(root.left, key);
       } else if (root.val < key) {
           root.right = deleteNode(root.right, key);
       }
       return root;
   }
   
   TreeNode getMin(TreeNode node) {
       // BST 最左边的就是最小的
       while (node.left != null) node = node.left;
       return node;
   }
   
   ```

   

7. 



### 图算法



### 数组