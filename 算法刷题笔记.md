# 算法刷题笔记

## 第零章  前  言

1. 数据结构基本分成两大类：数组和链表。对数据结构的操作大多数基于遍历访问，框架如下：

   ```c++
   void traverse(int[] arr) {
       for (int i = 0; i < arr.length; i++) {
           // 迭代访问 arr[i]
       }
   }
   ```

   ```c++
   /* 基本的单链表节点 */
   class ListNode {
       int val;
       ListNode next;
   }
   
   void traverse(ListNode head) {
       for (ListNode p = head; p != null; p = p.next) {
           // 迭代访问 p.val
       }
   }
   
   void traverse(ListNode head) {
       // 递归访问 head.val
       traverse(head.next);
   ```

   ```c++
   /* 基本的二叉树节点 */
   class TreeNode {
       int val;
       TreeNode left, right;
   }
   
   void traverse(TreeNode root) {
       traverse(root.left);
       traverse(root.right);
   }
   ```

   ```C++
   /* 基本的 N 叉树节点 */
   class TreeNode {
       int val;
       TreeNode[] children;//孩子用数组表示
   }
   
   void traverse(TreeNode root) {
       for (TreeNode child : root.children)
           traverse(child);
   }
   ```

2. 待补充

## 第一章  手把手刷数据结构

### 链表

1. **leetcode23「合并K个升序链表」**PriorityQueue中的元素在逻辑上构成了一棵完全二叉树，但是在实际存储时转换为了数组保存在内存中，它在遍历输出的时候总是先输出根节点的值，然后调整树使之继续成为一棵完全二叉树，每次输出的根节点总是整棵树优先级最高的，要么数值最小要么数值最大。

2. **leetcode19「删除链表的倒数第 N 个结点」**删除倒数第N个结点，就得获得倒数第n+1个节点的引用，如何找到倒数第k个节点，设置快慢指针，快指针先走k步即可。

3. **leetcode876「链表的中间结点」**快指针走两步，慢指针走一步

4. **判断链表是否包含环**同样的技巧，快指针走两步慢指针走一步，若是快慢指针相遇，则说明有环。若是要**找到环的起点**，则可以当快慢指针相遇时，慢指针重新指回头节点，然后两指针同步进行，相遇点即为环的起点。 

   <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220221212824498.png" alt="image-20220221212824498" style="zoom:60%;" />

   ```java
   ListNode detectCycle(ListNode head) {
       ListNode fast, slow;
       fast = slow = head;
       while (fast != null && fast.next != null) {
           fast = fast.next.next;
           slow = slow.next;
           if (fast == slow) break;
       }
       if (fast == null || fast.next == null) {
           // fast 遇到空指针说明没有环
           return null;
       }
   
       // 重新指向头结点
       slow = head;
       // 快慢指针同步前进，相交点就是环起点
       while (slow != fast) {
           fast = fast.next;
           slow = slow.next;
       }
       return slow;
   }
   ```

5. **leetcode160 「相交链表」**给你输入两个链表的头结点 headA和 headB，找出交点或NULL。

   解法1：让p1,p2分别遍历A，B链表，当遍历结束时，将另一个链表接在后面，这样进行拼接，就可以让 p1和p2 同时进入公共部分，也就是同时到达相交节点

   解法2：可以将A链表的结尾指向B链表的开头，问题转化为寻找链表中环的起点的问题
   
5. **leetcode206「反转链表」**重点在于递归解决思想，下面语句是核心

   ```java
   ListNode last = reverse(head.next);
   head.next.next=head;
   head.next=null;
   ```
   
   **「反转链表前 N 个节点」**
   
   ```java
   ListNode reverseN(ListNode head, int n) {
       if (n == 1) {
           // 记录第 n + 1 个节点
           successor = head.next;
           return head;
       }
       // 以 head.next 为起点，需要反转前 n - 1 个节点
       ListNode last = reverseN(head.next, n - 1);
   
       head.next.next = head;
       // 让反转之后的 head 节点和后面的节点连起来
       head.next = successor;
       return last;
   }
   ```
   
   **「反转链表的部分节点」**即给一个索引区间 [left,right]（索引从 1 开始），仅仅反转区间中的链表元素
   
   注意，若left=1，即转化为反转链表前right个节点；
   
   而当left!=1时，如果我们把head的索引视为 1，那么我们是想从第 m个元素开始反转，如果把 head.next的索引视为 1，那么相对于 head.next，反转的区间应该是从第 m - 1 个元素开始的，那么对于 head.next.next 呢……，直到最后相当于单个节点翻转，这就是递归
   
   ```java
   class Solution {
       ListNode successor=null;
       public ListNode reverseBetween(ListNode head, int left, int right) {
           if(left==1){
               return reverseN(head, right);
           }
            head.next = reverseBetween(head.next, left - 1, right - 1);
            return head;
       }
       public ListNode reverseN(ListNode head,int right){
           if(right==1){
               successor=head.next;
               return head;
           }
           ListNode last=reverseN(head.next,right-1);
           head.next.next=head;
           head.next=successor;
           return last;
       }
   }
   ```
   
7. **leetcode25「反转链表的部分节点」**

   首先实现翻转部分区间，从翻转整个链表的迭代法入手，

   ```java
   ListNode reverse(ListNode a) {
       ListNode pre, cur, nxt;
   	pre=null,cur=a,nxt=a;
   	 while (cur != null) {
           nxt = cur.next;
           // 逐个结点反转
           cur.next = pre;
           // 更新指针位置
           pre = cur;
           cur = nxt;
        }
       return pre;
   }
   ```

   如上所示，可以看出，若是翻转a到b之间的链表，只需要修改while判定条件即可；将上述过程融入迭代过程，即可实现按组翻转节点

   ```java
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head==null){
            return head;
        }
        ListNode a,b=head;
   	for(int i=0;i<k;i++){
           if (b == null) 
               return head;
           b = b.next;
       }
        ListNode newHead = reverse(a, b);
        a.next = reverseKGroup(b, k);
        return newHead;
    }
    
   ```

8. **leetcode 234 「反转链表的部分节点」**首先寻找回文串的核心思想是从中心向两端扩展，判断的话从两端到中心。

   由于单链表无法倒着遍历，无法使用双指针技巧，那么最简单的办法就是把原始链表反转存入一条新的链表，然后比较这两条链表是否相同。

   换个思路，链表--->二叉树，借助二叉树后序遍历的思路，链表兼具递归结构，树结构不过是链表的衍生，链表其实也可以有前序遍历和后序遍历：

   ```java
   void traverse(ListNode head) {
       // 前序遍历代码
       traverse(head.next);
       // 后序遍历代码
   }
   ```

   **实际上就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的**，只不过利用的是递归函数的堆栈

   ```java
   // 左侧指针
   ListNode left;
   
   boolean isPalindrome(ListNode head) {
       left = head;
       return traverse(head);
   }
   
   boolean traverse(ListNode right) {
       if (right == null) return true;
       boolean res = traverse(right.next);
       // 后序遍历代码，即判断是否是回文链
       res = res && (right.val == left.val);
       left = left.next;
       return res;
   }
   ```

   

### 二叉树



### 图算法



### 数组