# 算法刷题笔记

## 第零章  前  言

1. 数据结构基本分成两大类：数组和链表。对数据结构的操作大多数基于遍历访问，框架如下：

   ```c++
   void traverse(int[] arr) {
       for (int i = 0; i < arr.length; i++) {
           // 迭代访问 arr[i]
       }
   }
   ```

   ```c++
   /* 基本的单链表节点 */
   class ListNode {
       int val;
       ListNode next;
   }
   
   void traverse(ListNode head) {
       for (ListNode p = head; p != null; p = p.next) {
           // 迭代访问 p.val
       }
   }
   
   void traverse(ListNode head) {
       // 递归访问 head.val
       traverse(head.next);
   ```

   ```c++
   /* 基本的二叉树节点 */
   class TreeNode {
       int val;
       TreeNode left, right;
   }
   
   void traverse(TreeNode root) {
       traverse(root.left);
       traverse(root.right);
   }
   ```

   ```C++
   /* 基本的 N 叉树节点 */
   class TreeNode {
       int val;
       TreeNode[] children;//孩子用数组表示
   }
   
   void traverse(TreeNode root) {
       for (TreeNode child : root.children)
           traverse(child);
   }
   ```

2. 待补充

## 第一章  手把手刷数据结构

### 链表

1. **leetcode23「合并K个升序链表」**PriorityQueue中的元素在逻辑上构成了一棵完全二叉树，但是在实际存储时转换为了数组保存在内存中，它在遍历输出的时候总是先输出根节点的值，然后调整树使之继续成为一棵完全二叉树，每次输出的根节点总是整棵树优先级最高的，要么数值最小要么数值最大。

2. **leetcode19「删除链表的倒数第 N 个结点」**删除倒数第N个结点，就得获得倒数第n+1个节点的引用，如何找到倒数第k个节点，设置快慢指针，快指针先走k步即可。

3. **leetcode876「链表的中间结点」**快指针走两步，慢指针走一步

4. **判断链表是否包含环**同样的技巧，快指针走两步慢指针走一步，若是快慢指针相遇，则说明有环。若是要**找到环的起点**，则可以当快慢指针相遇时，慢指针重新指回头节点，然后两指针同步进行，相遇点即为环的起点。 

   <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220221212824498.png" alt="image-20220221212824498" style="zoom:60%;" />

   ```java
   ListNode detectCycle(ListNode head) {
       ListNode fast, slow;
       fast = slow = head;
       while (fast != null && fast.next != null) {
           fast = fast.next.next;
           slow = slow.next;
           if (fast == slow) break;
       }
       if (fast == null || fast.next == null) {
           // fast 遇到空指针说明没有环
           return null;
       }
   
       // 重新指向头结点
       slow = head;
       // 快慢指针同步前进，相交点就是环起点
       while (slow != fast) {
           fast = fast.next;
           slow = slow.next;
       }
       return slow;
   }
   ```

5. **leetcode160 「相交链表」**给你输入两个链表的头结点 headA和 headB，找出交点或NULL。

   解法1：让p1,p2分别遍历A，B链表，当遍历结束时，将另一个链表接在后面，这样进行拼接，就可以让 p1和p2 同时进入公共部分，也就是同时到达相交节点

   解法2：可以将A链表的结尾指向B链表的开头，问题转化为寻找链表中环的起点的问题

### 二叉树



### 图算法



### 数组