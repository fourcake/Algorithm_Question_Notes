# 算法刷题笔记

## 第零章  前  言

1. 数据结构基本分成两大类：数组和链表。对数据结构的操作大多数基于遍历访问，框架如下：

   ```c++
   void traverse(int[] arr) {
       for (int i = 0; i < arr.length; i++) {
           // 迭代访问 arr[i]
       }
   }
   ```

   ```c++
   /* 基本的单链表节点 */
   class ListNode {
       int val;
       ListNode next;
   }
   
   void traverse(ListNode head) {
       for (ListNode p = head; p != null; p = p.next) {
           // 迭代访问 p.val
       }
   }
   
   void traverse(ListNode head) {
       // 递归访问 head.val
       traverse(head.next);
   ```

   ```c++
   /* 基本的二叉树节点 */
   class TreeNode {
       int val;
       TreeNode left, right;
   }
   
   void traverse(TreeNode root) {
       traverse(root.left);
       traverse(root.right);
   }
   ```

   ```C++
   /* 基本的 N 叉树节点 */
   class TreeNode {
       int val;
       TreeNode[] children;//孩子用数组表示
   }
   
   void traverse(TreeNode root) {
       for (TreeNode child : root.children)
           traverse(child);
   }
   ```

2. 待补充

## 第一章  手把手刷数据结构

### 链表

1. **leetcode23「合并K个升序链表」**PriorityQueue中的元素在逻辑上构成了一棵完全二叉树，但是在实际存储时转换为了数组保存在内存中，它在遍历输出的时候总是先输出根节点的值，然后调整树使之继续成为一棵完全二叉树，每次输出的根节点总是整棵树优先级最高的，要么数值最小要么数值最大。

2. **leetcode19「删除链表的倒数第 N 个结点」**删除倒数第N个结点，就得获得倒数第n+1个节点的引用，如何找到倒数第k个节点，设置快慢指针，快指针先走k步即可。

3. **leetcode876「链表的中间结点」**快指针走两步，慢指针走一步

4. **判断链表是否包含环**同样的技巧，快指针走两步慢指针走一步，若是快慢指针相遇，则说明有环。若是要**找到环的起点**，则可以当快慢指针相遇时，慢指针重新指回头节点，然后两指针同步进行，相遇点即为环的起点。 

   <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220221212824498.png" alt="image-20220221212824498" style="zoom:60%;" />

   ```java
   ListNode detectCycle(ListNode head) {
       ListNode fast, slow;
       fast = slow = head;
       while (fast != null && fast.next != null) {
           fast = fast.next.next;
           slow = slow.next;
           if (fast == slow) break;
       }
       if (fast == null || fast.next == null) {
           // fast 遇到空指针说明没有环
           return null;
       }
   
       // 重新指向头结点
       slow = head;
       // 快慢指针同步前进，相交点就是环起点
       while (slow != fast) {
           fast = fast.next;
           slow = slow.next;
       }
       return slow;
   }
   ```

5. **leetcode160 「相交链表」**给你输入两个链表的头结点 headA和 headB，找出交点或NULL。

   解法1：让p1,p2分别遍历A，B链表，当遍历结束时，将另一个链表接在后面，这样进行拼接，就可以让 p1和p2 同时进入公共部分，也就是同时到达相交节点

   解法2：可以将A链表的结尾指向B链表的开头，问题转化为寻找链表中环的起点的问题
   
5. **leetcode206「反转链表」**重点在于递归解决思想，下面语句是核心

   ```java
   ListNode last = reverse(head.next);
   head.next.next=head;
   head.next=null;
   ```
   
   **「反转链表前 N 个节点」**
   
   ```java
   ListNode reverseN(ListNode head, int n) {
       if (n == 1) {
           // 记录第 n + 1 个节点
           successor = head.next;
           return head;
       }
       // 以 head.next 为起点，需要反转前 n - 1 个节点
       ListNode last = reverseN(head.next, n - 1);
   
       head.next.next = head;
       // 让反转之后的 head 节点和后面的节点连起来
       head.next = successor;
       return last;
   }
   ```
   
   **「反转链表的部分节点」**即给一个索引区间 [left,right]（索引从 1 开始），仅仅反转区间中的链表元素
   
   注意，若left=1，即转化为反转链表前right个节点；
   
   而当left!=1时，如果我们把head的索引视为 1，那么我们是想从第 m个元素开始反转，如果把 head.next的索引视为 1，那么相对于 head.next，反转的区间应该是从第 m - 1 个元素开始的，那么对于 head.next.next 呢……，直到最后相当于单个节点翻转，这就是递归
   
   ```java
   class Solution {
       ListNode successor=null;
       public ListNode reverseBetween(ListNode head, int left, int right) {
           if(left==1){
               return reverseN(head, right);
           }
            head.next = reverseBetween(head.next, left - 1, right - 1);
            return head;
       }
       public ListNode reverseN(ListNode head,int right){
           if(right==1){
               successor=head.next;
               return head;
           }
           ListNode last=reverseN(head.next,right-1);
           head.next.next=head;
           head.next=successor;
           return last;
       }
   }
   ```
   
7. **leetcode25「反转链表的部分节点」**

   首先实现翻转部分区间，从翻转整个链表的迭代法入手，

   ```java
   ListNode reverse(ListNode a) {
       ListNode pre, cur, nxt;
   	pre=null,cur=a,nxt=a;
   	 while (cur != null) {
           nxt = cur.next;
           // 逐个结点反转
           cur.next = pre;
           // 更新指针位置
           pre = cur;
           cur = nxt;
        }
       return pre;
   }
   ```

   如上所示，可以看出，若是翻转a到b之间的链表，只需要修改while判定条件即可；将上述过程融入迭代过程，即可实现按组翻转节点

   ```java
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head==null){
            return head;
        }
        ListNode a,b=head;
   	for(int i=0;i<k;i++){
           if (b == null) 
               return head;
           b = b.next;
       }
        ListNode newHead = reverse(a, b);
        a.next = reverseKGroup(b, k);
        return newHead;
    }
    
   ```

8. **leetcode 234 「反转链表的部分节点」**首先寻找回文串的核心思想是从中心向两端扩展，判断的话从两端到中心。

   由于单链表无法倒着遍历，无法使用双指针技巧，那么最简单的办法就是把原始链表反转存入一条新的链表，然后比较这两条链表是否相同。

   换个思路，链表--->二叉树，借助二叉树后序遍历的思路，链表兼具递归结构，树结构不过是链表的衍生，链表其实也可以有前序遍历和后序遍历：

   ```java
   void traverse(ListNode head) {
       // 前序遍历代码
       traverse(head.next);
       // 后序遍历代码
   }
   ```

   **实际上就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的**，只不过利用的是递归函数的堆栈

   ```java
   // 左侧指针
   ListNode left;
   
   boolean isPalindrome(ListNode head) {
       left = head;
       return traverse(head);
   }
   
   boolean traverse(ListNode right) {
       if (right == null) return true;
       boolean res = traverse(right.next);
       // 后序遍历代码，即判断是否是回文链
       res = res && (right.val == left.val);
       left = left.next;
       return res;
   }
   ```

   

### 二叉树

1. 二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着回溯算法核心框架和动态规划核心框架。

2. **leetcode 104 「二叉树的最大深度」**显然遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度，**这就是遍历二叉树计算答案的思路**。

   ```java
   // 记录最大深度
   int res = 0;
   // 记录遍历到的节点的深度
   int depth = 0;
   
   // 主函数
   int maxDepth(TreeNode root) {
   	traverse(root);
   	return res;
   }
   
   // 二叉树遍历框架
   void traverse(TreeNode root) {
   	if (root == null) {
   		// 到达叶子节点，更新最大深度
   		res = Math.max(res, depth);
   		return;
   	}
   	// 前序位置
   	depth++;
   	traverse(root.left);
   	traverse(root.right);
   	// 后序位置
   	depth--;
   }
   ```

   同样的，一棵树的最大深度可以有子树的最大深度推出，**这就是分解问题计算答案的思路**。

   ```java
   // 定义：输入根节点，返回这棵二叉树的最大深度
   int maxDepth(TreeNode root) {
   	if (root == null) {
   		return 0;
   	}
   	// 利用定义，计算左右子树的最大深度
   	int leftMax = maxDepth(root.left);
   	int rightMax = maxDepth(root.right);
   	// 整棵树的最大深度等于左右子树的最大深度取最大值，
       // 然后再加上根节点自己
   	int res = Math.max(leftMax, rightMax) + 1;
   
   	return res;
   }
   ```

3. 和前序位置对比，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的：**这意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

   1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？(前序)

   2、如何打印出每个节点的左右子树各有多少节点？（后序）

4. **leetcode 226「翻转二叉树」**细想，可以在前序或后序时插入交换子树操作，前序是从顶向下，后序从底向上

   ```Java
    public TreeNode invertTree(TreeNode root) {
           if(root==null) return null;
           invertTree(root.left);
           invertTree(root.right);
           //可放在前序也可放在后序
           TreeNode tmp = root.left;
           root.left = root.right;
           root.right = tmp;
           return root;
       }
   ```

5. **leetcode 116「填充二叉树节点的右侧指针」**首先若是模仿上一题代码，在前序遍历时直接 root.left.next = root.right，会导致以下问题

   <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220223145814649.png" alt="image-20220223145814649" style="zoom:50%;" />

   2号无法指向3号，5号无法指向6号，因为它们不是同一个父节点。**因此增加函数参数，一个节点做不到，就给他安排两个节点，将每一层二叉树节点连接起来可以细化成将每两个相邻节点都连接起来**

   ```java
   // 主函数
   Node connect(Node root) {
       if (root == null) return null;
       connectTwoNode(root.left, root.right);
       return root;
   }
   
   // 辅助函数
   void connectTwoNode(Node node1, Node node2) {
       if (node1 == null || node2 == null) {
           return;
       }
       /**** 前序遍历位置 ****/
       // 将传入的两个节点连接
       node1.next = node2;
       // 连接相同父节点的两个子节点
       connectTwoNode(node1.left, node1.right);
       connectTwoNode(node2.left, node2.right);
       // 连接跨越父节点的两个子节点
       connectTwoNode(node1.right, node2.left);
   }
   ```

   或者采用层序遍历更简单

6. **leetcode114 将二叉树展开为链表**

   ```java
   // 定义：将以 root 为根的树拉平为链表
   void flatten(TreeNode root) {
       // base case
       if (root == null) return;
       
       flatten(root.left);
       flatten(root.right);
   
       /**** 后序遍历位置 ****/
       // 1、保存副本
       TreeNode left = root.left;
       TreeNode right = root.right;
       
       // 2、将左子树作为右子树
       root.left = null;
       root.right = left;
   
       // 3、将原先的右子树接到当前右子树的末端
       TreeNode p = root;
       while (p.right != null) {
           p = p.right;
       }
       p.right = right;
   }
   ```

7. **leetcode 654 「构造最大二叉树」**根据题意，我们肯定要遍历数组把找到最大值 maxVal，把根节点 root做出来，然后对 maxVal左边的数组和右边的数组进行递归调用，作为 root的左右子树。按照题目给出的例子，输入的数组为 `[3,2,1,6,0,5]`，对于整棵树的根节点来说，其实在做这件事

   ```java
   TreeNode constructMaximumBinaryTree([3,2,1,6,0,5]) {
       // 找到数组中的最大值
       TreeNode root = new TreeNode(6);
       // 递归调用构造左右子树
       root.left = constructMaximumBinaryTree([3,2,1]);
       root.right = constructMaximumBinaryTree([0,5]);
       return root;
   }
   ```

   明确思路，再写一个辅助函数build来帮助控制nums的索引

   ```java
   /* 将 nums[lo..hi] 构造成符合条件的树，返回根节点 */
   TreeNode build(int[] nums, int lo, int hi) {
       // base case
       if (lo > hi) {
           return null;
       }
       //…………
   }
   ```

8. **leetcode 105 「通过前序和中序遍历还原二叉树」**纸老虎，直接想思路，首先思考，根节点应该做什么。**类似上一题，肯定要想办法确定根节点的值，把根节点做出来，然后递归构造左右子树即可**。

   <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220224112848257.png" alt="image-20220224112848257" style="zoom:67%;" />

   如上图所示，根节点很容易找到，preOrder的第一个元素就是，关键在于如何通过根节点的值，将 preorder 和 postorder 数组划分成两半，构造根节点的左右子树，即问号处填什么

   ```java
   TreeNode build(int[] preorder, int preStart, int preEnd, 
                  int[] inorder, int inStart, int inEnd) {
       // root 节点对应的值就是前序遍历数组的第一个元素
       int rootVal = preorder[preStart];
       // rootVal 在中序遍历数组中的索引
       int index = 0;
       for (int i = inStart; i <= inEnd; i++) {
           if (inorder[i] == rootVal) {
               index = i;
               break;
           }
       }
       TreeNode root = new TreeNode(rootVal);
       // 递归构造左右子树
       root.left = build(preorder, ?, ?, inorder, ?, ?);
   
       root.right = build(preorder, ?, ?, inorder, ?, ?);
       return root;
   }
   
   ```

   <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220224112904491.png" alt="image-20220224112904491" style="zoom:67%;" />

   显然，左右子树划分应该为

   ```java
   root.left = build(preorder, preStart+1, preStart+leftSize, inorder, inStart, index-1);
   root.right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index+1, inEnd);
   ```

9. **leetcode 106 「通过后序和中序遍历还原二叉树」**原理和上题一摸一样

   ```java
   public TreeNode build(int[] inorder,int inStart,int inEnd, int[] postorder,int postStart,int postEnd) {
           if (postStart > postEnd) {
               return null;
           }
           int rootVal = postorder[postEnd];
           int index = 0;
           for (int i = inStart; i <= inEnd; i++) {
               if (inorder[i] == rootVal) {
                   index = i;
                   break;
               }
           }
           TreeNode root = new TreeNode(rootVal);
           int leftSize = index - inStart;
           // 递归构造左右子树
           root.left = build(inorder, inStart, index-1,postorder, postStart, postStart + leftSize - 1);
   
           root.right = build(inorder, index+1, inEnd,postorder, postStart + leftSize, postEnd - 1);
   
           return root;
        }
   ```

10. **leetcode 889 「根据前序和后序遍历构造二叉树」**这道题和前两道题有一个本质的区别：**通过前序中序，或者后序中序遍历结果可以确定一棵原始二叉树，但是通过前序后序遍历结果无法确定原始二叉树**。

    不过话说回来，用后序遍历和前序遍历结果还原二叉树，解法逻辑上和前两道题差别不大，也是通过控制左右子树的索引来构建：
    
    **1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值**。
    
    **2、然后把前序遍历结果的第二个元素作为左子树的根节点的值**。
    
    **3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可**。
    
    <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220226184129317.png" alt="image-20220226184129317" style="zoom:67%;" />
    
    ```java
     TreeNode build(int[] preorder, int preStart, int preEnd,
                       int[] postorder, int postStart, int postEnd) {
            if (preStart > preEnd) {
                return null;
            }
            if (preStart == preEnd) {
                return new TreeNode(preorder[preStart]);
            }
    
            // root 节点对应的值就是前序遍历数组的第一个元素
            int rootVal = preorder[preStart];
            // root.left 的值是前序遍历第二个元素
            // 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点
            // 确定 preorder 和 postorder 中左右子树的元素区间
            int leftRootVal = preorder[preStart + 1];
            // leftRootVal 在后序遍历数组中的索引
            int index = 0;
            for (int i = postStart; i < postEnd; i++) {
                if (postorder[i] == leftRootVal) {
                    index = i;
                    break;
                }
            }
            // 左子树的元素个数
            int leftSize = index - postStart + 1;
    
            // 先构造出当前根节点
            TreeNode root = new TreeNode(rootVal);
            // 递归构造左右子树
            // 根据左子树的根节点索引和元素个数推导左右子树的索引边界
            root.left = build(preorder, preStart + 1, preStart + leftSize,
                    postorder, postStart, index);
            root.right = build(preorder, preStart + leftSize + 1, preEnd,
                    postorder, index + 1, postEnd - 1);
    
            return root;
    }
    ```
    
11. **leetcode 652「寻找重复的子树」**给定一棵二叉树 root，返回所有重复的子树

    <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220226184144398.png" alt="image-20220226184144398" style="zoom:67%;" />

    首先思考框架，我要找到相同的子树，首先我得知道自己节点的子树长什么样，其次，我还得知道别人的子树长什么样子，这样才能对比，因此选择后序遍历框架

    决定框架后，思考，如何对比子树是否长得一样，这就涉及到树的序列化，将树表示成一串字符串，空处用#表示

    当有了子树序列后，如何判断是否重复呢，运用hashmap可以很好的解决此问题

    ```java
    class Solution {
        HashMap <String,Integer> memo=new HashMap<>();
        LinkedList <TreeNode> res=new LinkedList<>();
    
        public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
            travers(root);
            return res;
        }
        public String travers(TreeNode root){
            if(root==null){
                return "#";
            }
            String left=travers(root.left);
            String right=travers(root.right);
            //序列化框架
            String subTree=left+","+right+","+root.val;
            //getOrDefault：查找目标值，获取指定key对应的value，若是不存在，则返回默认参数
            int freq=memo.getOrDefault(subTree,0);
            if(freq==1){
                res.add(root);
            }
            memo.put(subTree,freq+1);
            return subTree;
        }
    }
    ```

12. **leetcode 236 二叉树最近公共祖先**先考虑用后序遍历的框架

    ​		情况 1，如果 `p` 和 `q` 都在以 `root` 为根的树中，那么 `left` 和 `right` 一定分别是 `p` 和 `q`（从 base case 看出来的）。

    ​		情况 2，如果 `p` 和 `q` 都不在以 `root` 为根的树中，直接返回 `null`。

    ​		情况 3，如果 `p` 和 `q` 只有一个存在于 `root` 为根的树中，函数返回该节点。

    ```java
    class Solution {
        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
            // base case
            if (root == null) return null;
            if (root == p || root == q) return root;
    
            TreeNode left = lowestCommonAncestor(root.left, p, q);
            TreeNode right = lowestCommonAncestor(root.right, p, q);
            // 情况 1
            if (left != null && right != null) {
                return root;
            }
            // 情况 2
            if (left == null && right == null) {
                return null;
            }
            // 情况 3
            return left == null ? right : left;
        }
    }
    ```

    

### 二叉搜索树

二叉搜索树（BST）并不算复杂，直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。

1. **leetcode 230「二叉搜索树的第k小元素」**BST 的中序遍历其实就是升序排序的结果，每次寻找第 k 小的元素都要中序遍历一次，最坏的时间复杂度是 O(N)，相对于BST的性质来说有点低效了，计算第k小元素，最好的算法肯定也是对数级别的复杂度。

   想找到第 k小的元素并且达到对数级复杂度，关键也在于每个节点得知道他自己排第几

   <img src="images/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220301211654780.png" alt="image-20220301211654780" style="zoom:67%;" />

   需要在二叉树节点中维护额外信息。**每个节点需要记录，以自己为根的这棵二叉树有多少个节点**。

2. **leetcode 538「将二叉搜索树转换为累加树」**还是利用 BST 的中序遍历特性，降序排列只要把递归顺序改一下就行了：**因此可以降序打印 BST 节点的值，如果维护一个外部累加变量 `sum`，然后把 `sum` 赋值给 BST 中的每一个节点，即可**

   ```java
   TreeNode convertBST(TreeNode root) {
       traverse(root);
       return root;
   }
   
   // 记录累加和
   int sum = 0;
   void traverse(TreeNode root) {
       if (root == null) {
           return;
       }
       traverse(root.right);
       // 维护累加和
       sum += root.val;
       // 将 BST 转化成累加树
       root.val = sum;
       traverse(root.left);
   }
   ```

3. **leetcode 98「验证二叉搜索树」**需要注意的是，单纯比较当前节点和其左右子树大小是无法完整验证BST的，对于某一个节点 root，他只能管得了自己的左右子节点，怎么把 root 的约束传递给左右子树呢？

   **通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点**

   ```java
   boolean isValidBST(TreeNode root) {
       return isValidBST(root, null, null);
   }
   
   /* 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val */
   boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
       // base case
       if (root == null) return true;
       // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
       if (min != null && root.val <= min.val) return false;
       if (max != null && root.val >= max.val) return false;
       // 限定左子树的最大值是 root.val，右子树的最小值是 root.val
       return isValidBST(root.left, min, root) 
           && isValidBST(root.right, root, max);
   }
   
   ```

4. **leetcode 700「二叉搜索树中的搜索」**运用性质

   ```java
   TreeNode searchBST(TreeNode root, int target) {
       if (root == null) {
           return null;
       }
       // 去左子树搜索
       if (root.val > target) {
           return searchBST(root.left, target);
       }
       // 去右子树搜索
       if (root.val < target) {
           return searchBST(root.right, target);
       }
       return root;
   }
   
   ```

5. **leetcode 701「二叉搜索树中的插入」**

   ```java
   TreeNode insertIntoBST(TreeNode root, int val) {
       // 找到空位置插入新节点
       if (root == null) return new TreeNode(val);
       // if (root.val == val)
       //     BST 中一般不会插入已存在元素
       if (root.val < val) 
           root.right = insertIntoBST(root.right, val);
       if (root.val > val) 
           root.left = insertIntoBST(root.left, val);
       return root;
   }
   ```

   

6.  **leetcode 450「二叉搜索树中的删除」**跟插入操作类似，先「找」再「改」，框架如下：

   ```java
   TreeNode deleteNode(TreeNode root, int key) {
       if (root.val == key) {
           // 找到啦，进行删除
       } else if (root.val > key) {
           // 去左子树找
           root.left = deleteNode(root.left, key);
       } else if (root.val < key) {
           // 去右子树找
           root.right = deleteNode(root.right, key);
       }
       return root;
   }
   ```

   找到之后，分三种情况进行删除操作：恰好是叶子节点、有一个孩子为空、有两个子节点

   ```java
   TreeNode deleteNode(TreeNode root, int key) {
       if (root == null) return null;
       if (root.val == key) {
           // 这两个 if 把情况 1 和 2 都正确处理了
           if (root.left == null) return root.right;
           if (root.right == null) return root.left;
           // 处理情况 3
           // 获得右子树最小的节点
           TreeNode minNode = getMin(root.right);
           // 删除右子树最小的节点
           root.right = deleteNode(root.right, minNode.val);
           // 用右子树最小的节点替换 root 节点
           minNode.left = root.left;
           minNode.right = root.right;
           root = minNode;
       } else if (root.val > key) {
           root.left = deleteNode(root.left, key);
       } else if (root.val < key) {
           root.right = deleteNode(root.right, key);
       }
       return root;
   }
   
   TreeNode getMin(TreeNode node) {
       // BST 最左边的就是最小的
       while (node.left != null) node = node.left;
       return node;
   }
   
   ```

   

7. **leetcode 96「不同的二叉搜索树」**求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种。例如n=5，以3为root来看，划分为{1，2}和{4，5}，从而我们需要继续细分，算出左子树种类数乘以右子树种类数

   ```java
   class Solution {
       int [][] memo;
       public int numTrees(int n) {
           memo=new int[n+1][n+1];
           return count(1, n);
       }
       public int count(int lo,int hi){
           if(lo>hi){
               return 1;
           }
           if(memo[lo][hi]!=0){
               return memo[lo][hi];
           }
           int res=0;
           for(int i=lo;i<=hi;i++){
               int left=count(lo,i-1);
               int right=count(i+1,hi);
               res+=left*right;
           }
           memo[lo][hi]=res;
           return res;  
       }
   }
   ```

   

8. **leetcode 1373「二叉搜索子树的最大键值和」**站在当前节点的视角，需要知道以下具体信息：（后序遍历）

   1、左右子树是否是 BST。

   2、左子树的最大值和右子树的最小值。

   3、左右子树的节点值之和。

   ```java
   int maxSum = 0;
       /* 主函数 */
   public int maxSumBST(TreeNode root) {
   	traverse(root);
       return maxSum;
   }
   int[] traverse(TreeNode root) {
       // base case
       if (root == null) {
           return new int[] {
               1, Integer.MAX_VALUE, Integer.MIN_VALUE, 0
           };
       }
       // 递归计算左右子树
       int[] left = traverse(root.left);
       int[] right = traverse(root.right);
       
       /******* 后序遍历位置 *******/
       int[] res = new int[4];
       // 这个 if 在判断以 root 为根的二叉树是不是 BST
       if (left[0] == 1 && right[0] == 1 &&
           root.val > left[2] && root.val < right[1]) {
           // 以 root 为根的二叉树是 BST
           res[0] = 1;
           // 计算以 root 为根的这棵 BST 的最小值
           res[1] = Math.min(left[1], root.val);
           // 计算以 root 为根的这棵 BST 的最大值
           res[2] = Math.max(right[2], root.val);
           // 计算以 root 为根的这棵 BST 所有节点之和
           res[3] = left[3] + right[3] + root.val;
           // 更新全局变量
           maxSum = Math.max(maxSum, res[3]);
       } else {
           // 以 root 为根的二叉树不是 BST
           res[0] = 0;
           // 其他的值都没必要计算了，因为用不到
       }
       /**************************/
       
       return res;
   }
   
   ```

   `traverse(root)` 返回一个大小为 4 的 int 数组，我们暂且称它为 `res`，其中：

   `res[0]` 记录以 `root` 为根的二叉树是否是 BST，若为 1 则说明是 BST，若为 0 则说明不是 BST；

   `res[1]` 记录以 `root` 为根的二叉树所有节点中的最小值；

   `res[2]` 记录以 `root` 为根的二叉树所有节点中的最大值；

   `res[3]` 记录以 `root` 为根的二叉树所有节点值之和。

   **最重要的是，我们要试图通过 `left` 和 `right` 正确推导出 `res` 数组**。

### 二叉树序列化与反序列化

**leetcode 297「二叉树序列化与反序列化」**

1. 前序遍历框架

   序列化：

   ```java
   // 代表分隔符的字符
   String SEP = ",";
   // 代表 null 空指针的字符
   String NULL = "#";
   // 用于拼接字符串
   StringBuilder sb = new StringBuilder();
   
   /* 将二叉树打平为字符串 */
   void traverse(TreeNode root, StringBuilder sb) {
       if (root == null) {
           sb.append(NULL).append(SEP);
           return;
       }
   
       /****** 前序遍历位置 ******/
       sb.append(root.val).append(SEP);
       /***********************/
   
       traverse(root.left, sb);
       traverse(root.right, sb);
   }
   
   ```

   反序列化：前序遍历的第一个节点就是一棵树的根节点

   ```java
   public TreeNode deserialize(String data) {
           LinkedList<String> nodes=new LinkedList<String>();
           for(String s:data.split(",")){
               nodes.addLast(s);
           }
           return traverse2(nodes);
       }
   
       public TreeNode traverse2(LinkedList<String> nodes){
           if(nodes.isEmpty()){
               return null;
           }
           String first=nodes.removeFirst();
           if(first.equals("#")){
               return null;
           }
           TreeNode root=new TreeNode(Integer.parseInt(first));
           root.left=traverse2(nodes);
           root.right=traverse2(nodes);
           return root;
       }
   ```

   

2. 后序遍历框架

   ```java
   /* 辅助函数，将二叉树存入 StringBuilder */
   void serialize(TreeNode root, StringBuilder sb) {
       if (root == null) {
           sb.append(NULL).append(SEP);
           return;
       }
   
       serialize(root.left, sb);
       serialize(root.right, sb);
   
       /****** 后序遍历位置 ******/
       sb.append(root.val).append(SEP);
       /***********************/
   }
   
   /* 主函数，将字符串反序列化为二叉树结构 */
   TreeNode deserialize(String data) {
       LinkedList<String> nodes = new LinkedList<>();
       for (String s : data.split(SEP)) {
           nodes.addLast(s);
       }
       return deserialize(nodes);
   }
   
   /* 辅助函数，通过 nodes 列表构造二叉树 */
   TreeNode deserialize(LinkedList<String> nodes) {
       if (nodes.isEmpty()) return null;
       // 从后往前取出元素
       String last = nodes.removeLast();
       if (last.equals(NULL)) return null;
       TreeNode root = new TreeNode(Integer.parseInt(last));
       // 限构造右子树，后构造左子树
       root.right = deserialize(nodes);
       root.left = deserialize(nodes);
   
       return root;
   }
   
   ```

### 迭代器

**leetcode 341「扁平化嵌套链表迭代器」**

分析题目要求，其实就是个N叉树的叶子节点遍历，关于迭代器，还是得看看Collection类的Iterator源码

```java
private LinkedList<NestedInteger> list;

public NestedIterator(List<NestedInteger> nestedList) {
	// 不直接用 nestedList 的引用，是因为不能确定它的底层实现
    // 必须保证是 LinkedList，否则下面的 addFirst 会很低效
    list = new LinkedList<>(nestedList);
}

public Integer next() {
    // hasNext 方法保证了第一个元素一定是整数类型
    return list.remove(0).getInteger();
}

public boolean hasNext() {
    // 循环拆分列表元素，直到列表第一个元素是整数类型
    while (!list.isEmpty() && !list.get(0).isInteger()) {
          // 当列表开头第一个元素是列表类型时，进入循环
          List<NestedInteger> first = list.remove(0).getList();
          // 将第一个列表打平并按顺序添加到开头
          for (int i = first.size() - 1; i >= 0; i--) {
              list.addFirst(first.get(i));
          }
    }
    return !list.isEmpty();
}
```

### 归并排序

待补充

### 二叉树递归改迭代

待补充



### 图算法

有向加权图结构

```java
// 邻接表
// graph[x] 存储 x 的所有邻居节点以及对应的权重
List<int[]>[] graph;
// 邻接矩阵
// matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻
int[][] matrix;
```

图的遍历，其实可以参考多叉树的遍历，

```java
/* 多叉树遍历框架 */
void traverse(TreeNode root) {
    if (root == null) return;

    for (TreeNode child : root.children) {
        traverse(child);
    }
}
```

图和多叉树最大的区别是，图是可能包含环的，所以，如果图包含环，遍历框架就要一个 visited数组进行辅助（无环则可省略）：

```java
// 记录被遍历过的节点
boolean[] visited;
// 记录从起点到当前节点的路径
boolean[] onPath;
/* 图遍历框架 */
void traverse(Graph graph, int s) {
    if (visited[s]) return;
    // 经过节点 s，标记为已遍历
    visited[s] = true;
    // 做选择：标记节点 s 在路径上
    onPath[s] = true;
    for (int neighbor : graph.neighbors(s)) {
        traverse(graph, neighbor);
    }
    // 撤销选择：节点 s 离开路径
    onPath[s] = false;
}
```

**leetcode 797「所有可能的路径」**给定一个有向无环图，找出0到n-1的所有路径，整体是按框架写的

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        LinkedList<Integer> path = new LinkedList<>();
        traverse(graph, 0, path);
        return res;
    }
    /* 图的遍历框架 */
    void traverse(int[][] graph, int s, LinkedList<Integer> path) {
        // 添加节点 s 到路径
        path.addLast(s);
        int n = graph.length;
        if (s == n - 1) {
            // 到达终点
            res.add(new LinkedList<>(path));
            path.removeLast();
            return;
        }
        // 递归每个相邻节点
        for (int v : graph[s]) {
            traverse(graph, v, path);
        }
        // 从路径移出节点 s
        path.removeLast();
    }
}
```

### BFS、DFS框架

BFS 相对 DFS 的最主要的区别是：**BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多**

```java
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路
    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数
    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj()) {
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
            }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}
```

**1、为什么 BFS 可以找到最短距离，DFS 不行吗**？

BFS 的逻辑，`depth` 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。

DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对高很多。你想啊，DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长对不对？而 BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。

**2、既然 BFS 那么好，为啥 DFS 还要存在**？

BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。

还是拿二叉树的例子，假设给你的这个二叉树是满二叉树，节点数为 `N`，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 `O(logN)`。

但是BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 `N/2`，用 Big O 表示的话也就是 `O(N)`。

**由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。**

**leetcode 752「打开转盘锁」**

穷举，简单一点，如果你只转一下锁，有几种可能？总共有 4 个位置，每个位置可以向上转，也可以向下转，也就是有 8 种可能。**仔细想想，这就可以抽象成一幅图，每个节点有 8 个相邻的节点**，又让你求最短距离，这不就是典型的 BFS 

```java
class Solution {
    String plusOne(String s,int j){
        char[] ch = s.toCharArray();
        if (ch[j] == '9')
            ch[j] = '0';
        else
            ch[j] += 1;
        return new String(ch);
    }
// 将 s[i] 向下拨动一次
    String minusOne(String s, int j) {
        char[] ch = s.toCharArray();
        if (ch[j] == '0')
            ch[j] = '9';
        else
            ch[j] -= 1;
        return new String(ch);
    }

    public int openLock(String[] deadends, String target) {
        // 记录需要跳过的死亡密码
        Set<String> deads = new HashSet<>();
        for (String s : deadends) deads.add(s);
        // 记录已经穷举过的密码，防止走回头路
        Set<String> visited = new HashSet<>();
        Queue<String> q = new LinkedList<>();
        // 从起点开始启动广度优先搜索
        int step = 0;
        q.offer("0000");
        visited.add("0000");
             
        while (!q.isEmpty()) {
            int sz = q.size();
            /* 将当前队列中的所有节点向周围扩散 */
            for (int i = 0; i < sz; i++) {
                String cur = q.poll();
                /* 判断是否到达终点 */
                if (deads.contains(cur))
                    continue;
                if (cur.equals(target))
                    return step;
                /* 将一个节点的未遍历相邻节点加入队列 */
                for (int j = 0; j < 4; j++) {
                    String up = plusOne(cur, j);
                    if (!visited.contains(up)) {
                        q.offer(up);
                        visited.add(up);
                    }
                    String down = minusOne(cur, j);
                    if (!visited.contains(down)) {
                        q.offer(down);
                        visited.add(down);
                    }
                }
            }
            /* 在这里增加步数 */
            step++;
        }
        return -1;
    }
}
```



### 拓扑排序详解及应用（解决依赖问题）

**leetcode 207「课程表（图中环检测 ）--DFS」**解决课程之间先修与后修路径关系，什么时候无法修完所有课程？当存在循环依赖的时候。**看到依赖问题，首先想到的就是把问题转化成「有向图」这种数据结构，只要图中存在环，那就说明存在循环依赖**。所以首先应该根据题目描述建图

```java
List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        // 图中共有 numCourses 个节点
        List<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : prerequisites) {
            int from = edge[1], to = edge[0];
            // 添加一条从 from 指向 to 的有向边
            // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
            graph[from].add(to);
        }
        return graph;
    }
```

遍历图，onpath用来判断是否出现环，visit用来记录是否访问过该点

```java
    // 记录一次递归堆栈中的节点
    boolean[] onPath;
    // 记录遍历过的节点，防止走回头路
    boolean[] visited;
    // 记录图中是否有环
    boolean hasCycle = false;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);
        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];
        for (int i = 0; i < numCourses; i++) {
            traverse(graph, i);
        }
        return !hasCycle;
    }
    void traverse(List<Integer>[] graph, int s) {
        if (onPath[s]) {
            hasCycle = true;
        }
        if (visited[s] || hasCycle) {
            // 如果已经找到了环，也不用再遍历了
            return;
        }
        // 前序代码位置
        visited[s] = true;
        onPath[s] = true;
        for (int t : graph[s]) {
            traverse(graph, t);
        }
        // 后序代码位置
        onPath[s] = false;
    }
```

**leetcode 207「课程表（图中环检测 ）--BFS」**

 BFS 算法的思路：

1、构建邻接表，和之前一样，边的方向表示「被依赖」关系。

2、构建一个indegree数组记录每个节点的入度，即 `indegree[i]` 记录节点 `i` 的入度。

3、对 BFS 队列进行初始化，将入度为 0 的节点首先装入队列。

**4、开始执行 BFS 循环，不断弹出队列中的节点，减少相邻节点的入度，并将入度变为 0 的节点加入队列**。

**5、如果最终所有节点都被遍历过（`count` 等于节点数），则说明不存在环，反之则说明存在环**。

```java
// 主函数
public boolean canFinish(int numCourses, int[][] prerequisites) {
    // 建图，有向边代表「被依赖」关系
    List<Integer>[] graph = buildGraph(numCourses, prerequisites);
    //构建入度数组
    int[] indgree=new int[numCourses];
    for (int[] edge : prerequisites) {
        int from = edge[1], to = edge[0];
        // 节点 to 的入度加一
        indgree[to]++;
    }
    // 根据入度初始化队列中的节点
    Queue<Integer> q = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (indgree[i] == 0) {
            // 节点 i 没有入度，即没有依赖的节点
            // 可以作为拓扑排序的起点，加入队列
            q.offer(i);
        }
    }
     // 记录遍历的节点个数
    int count = 0;
    // 开始执行 BFS 循环
    while (!q.isEmpty()) {
        // 弹出节点 cur，并将它指向的节点的入度减一
        int cur = q.poll();
        count++;
        for (int next : graph[cur]) {
            indgree[next]--;
            if (indgree[next] == 0) {
                // 如果入度变为 0，说明 next 依赖的节点都已被遍历
                q.offer(next);
            }
        }
    }
     // 如果所有节点都被遍历过，说明不成环
    return count == numCourses;
}
List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
    // 图中共有 numCourses 个节点
    List<Integer>[] graph = new LinkedList[numCourses];
    for (int i = 0; i < numCourses; i++) {
        graph[i] = new LinkedList<>();
    }
    for (int[] edge : prerequisites) {
        int from = edge[1], to = edge[0];
        // 添加一条从 from 指向 to 的有向边
        // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
        graph[from].add(to);
    }
    return graph;
}
    
```

**leetcode 210「课程表Ⅱ（可行路径输出）--DFS」**拓扑排序要求必须是有向无环图

```JAVA
// 记录后序遍历结果
List<Integer> postorder = new ArrayList<>();
// 记录是否存在环
boolean hasCycle = false;
boolean[] visited, onPath;

// 主函数
public int[] findOrder(int numCourses, int[][] prerequisites) {
    List<Integer>[] graph = buildGraph(numCourses, prerequisites);
    visited = new boolean[numCourses];
    onPath = new boolean[numCourses];
    // 遍历图
    for (int i = 0; i < numCourses; i++) {
        traverse(graph, i);
    }
    // 有环图无法进行拓扑排序
    if (hasCycle) {
        return new int[]{};
    }
    // 逆后序遍历结果即为拓扑排序结果
    Collections.reverse(postorder);
    int[] res = new int[numCourses];
    for (int i = 0; i < numCourses; i++) {
        res[i] = postorder.get(i);
    }
    return res;
}

// 图遍历函数
void traverse(List<Integer>[] graph, int s) {
    if (onPath[s]) {
        // 发现环
        hasCycle = true;
    }
    if (visited[s] || hasCycle) {
        return;
    }
    // 前序遍历位置
    onPath[s] = true;
    visited[s] = true;
    for (int t : graph[s]) {
        traverse(graph, t);
    }
    // 后序遍历位置
    postorder.add(s);
    onPath[s] = false;
}

// 建图函数
List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
    // 代码见前文
}
```

**leetcode 210「课程表Ⅱ（可行路径输出）--BFS」**

BFS遍历节点的顺序就是拓扑排序路径

```java
// 主函数
public int[] findOrder(int numCourses, int[][] prerequisites) {
    // 建图，和环检测算法相同
    List<Integer>[] graph = buildGraph(numCourses, prerequisites);
    // 计算入度，和环检测算法相同
    int[] indgree = new int[numCourses];
    for (int[] edge : prerequisites) {
        int from = edge[1], to = edge[0];
        indgree[to]++;
    }
    // 根据入度初始化队列中的节点，和环检测算法相同
    Queue<Integer> q = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (indgree[i] == 0) {
            q.offer(i);
        }
    }
	// 记录拓扑排序结果
    int[] res = new int[numCourses];
    // 记录遍历节点的顺序（索引）
    int count = 0;
    // 开始执行 BFS 算法
    while (!q.isEmpty()) {
        int cur = q.poll();
        // 弹出节点的顺序即为拓扑排序结果
        res[count] = cur;
        count++;
        for (int next : graph[cur]) {
            indgree[next]--;
            if (indgree[next] == 0) {
                q.offer(next);
            }
        }
    }
    if (count != numCourses) {
        // 存在环，拓扑排序不存在
        return new int[]{};
    }
    return res;
}

List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
    // 图中共有 numCourses 个节点
    List<Integer>[] graph = new LinkedList[numCourses];
    for (int i = 0; i < numCourses; i++) {
        graph[i] = new LinkedList<>();
    }
    for (int[] edge : prerequisites) {
        int from = edge[1], to = edge[0];
        // 添加一条从 from 指向 to 的有向边
        // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
        graph[from].add(to);
    }
    return graph;
}
```

### 二分图

**leetcode 785「判断二分图--DFS」**

```java 
// 记录图是否符合二分图性质
private boolean ok = true;
// 记录图中节点的颜色，false 和 true 代表两种不同颜色
private boolean[] color;
// 记录图中节点是否被访问过
private boolean[] visited;


public boolean isBipartite(int[][] graph){
    int n=graph.length;
    color=new boolean[n];
    visited=new  boolean[n];
    for(int v=0;v<n;v++){
		if(!visited[n]){
            traverse(graph, v);
        }
    }
    return ok;
}
// DFS 遍历框架
private void traverse(int[][] graph, int v) {
    if(!ok) return;
    visited[v]=true;
    for(int w:graph[v]){
        if(!visited[w]){
            // 相邻节点 w 没有被访问过
            // 那么应该给节点 w 涂上和节点 v 不同的颜色
            color[w] = !color[v];
            // 继续遍历 w
            traverse(graph, w);
        }else{
            // 相邻节点 w 已经被访问过
            // 根据 v 和 w 的颜色判断是否是二分图
            if (color[w] == color[v]) {
                // 若相同，则此图不是二分图
                ok = false;
            }
        }
    }
      
}
```

**leetcode 785「判断二分图--BFS」**

```java
// 记录图是否符合二分图性质
private boolean ok = true;
// 记录图中节点的颜色，false 和 true 代表两种不同颜色
private boolean[] color;
// 记录图中节点是否被访问过
private boolean[] visited;
public boolean isBipartite(int[][] graph) {
    int n = graph.length;
    color =  new boolean[n];
    visited =  new boolean[n];
    
    for (int v = 0; v < n; v++) {
        if (!visited[v]) {
            // 改为使用 BFS 函数
            bfs(graph, v);
        }
    }
    return ok;
}

// 从 start 节点开始进行 BFS 遍历
private void bfs(int[][] graph, int start) {
    Queue<Integer> q = new LinkedList<>();
    visited[start] = true;
    q.offer(start);
    
    while(!q.isEmpty()&&ok){
        int v=q.poll();
        for(int w:graph[v]){
            if(!visited[w]){
                color[w] = !color[v];
                // 标记 w 节点，并放入队列
                visited[w] = true;
                q.offer(w);
            }else{
                if (color[w] == color[v]) {
                    // 若相同，则此图不是二分图
                    ok = false;
                }
            }
        }
    }
   
}

```

### 数组